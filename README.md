# Изучаем Q#. Встретились как-то Гровер и Цезарь ...
Криптохомячкам посвящается ...
Алгоритм Гровера представляет собой обобщённый, независящей от конкретной задачи поиск, функция которого представляет "чёрный ящик"
f: {0,1}^n -> {0,1}^n, для которой известно, что EXIST!w:f(w)=a, где a - заданное значение.
Считаем, что для f и заданного a можно построить оракул Uf: { w->1, x->0 if x!=w }
Алгоритм Гровера достаточно прост 
1. Задаём в регистре (массиве кубитов) начальное значение H|0>
2. Повторяем несколько раз (исходя из оценки) пару трансформаций над регистром
2.1. Отражение от решения Uw: { w->-w, x->x if x!=w } или Uw = I-2|w><w|
2.2. Отражение от s=H|0> Us = 2|s><s|-I
3. Забираем нужное решение из регистра (с большой долей вероятности, что оно правильное)
Применим этот алгорим для решения задачи нахождения ключа для шифра Цезаря.
Шифр Цезаря - это один из моноалфавитных шифров, где алфавит может быть представлен как кольцо вычетов Z|m.
И, если ключ key - число из 0..(m-1), а x(i) - где i=0..(l-1) и являются числами из 0..(m-1), то
y(i) = (x(i)+key) mod m - является шифротекстом.
Соответственно, x(i) = (y(i) - key) mod m = (y(i) + (m-key)) mod m - является процедурой расшифрования.
Для рассмотрения задачи, предположим, что в открытом тексте некоторые символы из Z|m встречаются редко или не встречаются совсем.
Что будет означать данный факт - то что имея шифротекст y(i) мы можем выполнить следующие действия
1. будем перебирать все возможные значения ключа key
2. для данного ключа получим открытый текст x(i)
3. у данного открытого текста x(i) подсчитаем количество "неправильных" символов - то есть тех - которые не встречаются совсем (или встречаются очень редко)
4. среди всех ключей выбнрем тот - у которого полученное количество "неправильных" символов ноль (или минимально)
Таким образом, по шифротексту и зная ограничения на символы открытого текста мы методом грубой силы получим значение ключа для шифра Цезаря.
Очевидно, что приведённый алгорим является по своей сути реализацией следующей задачи
Дано Error:Z|m->N
Требуется найти такой key, что Error(key)=0
А это и есть условие для применения алгоритма Гровера
NB. Очевидно, что подобные рассуждения можно провести для любого блочного шифра как в режиме ECB, так и в режиме CBC
Перейдём к реализации
Пусть m=2^n и про открытый текст известно, что старший разряд в двоичном представлении числа-символа открытого текста всегда равен 0
Реализуем следующие методы
1. Метод арифметики над регистром из кубитов - увеличение значения на единицу, то есть трансформация |k>->|k+1>
2. Метод арифметики над регистром из кубитов - увеличение значения на заданную величину value, то есть трансформация |k>->|k+value>
3. Методы генерации случайного ключа и случайно последовательности открытого текста (с учётом введёного ограничения на символы открытого текста)
4. Метод шифрования шифром Цезаря
5. Метод подсчёта количества "неправильных" символов для заданного шифротекста и заданного ключа
6. Реализацию оракла - который выдаёт |1> если для опробоваемого ключа количество "неправильных" символов равно 0
7. Методы аглоритам Гровера
1. Отражение от решения
2. Отражение от H|0>
3. Собственно, основной цикл алгоритма Гровера

Подготовим тест
1. Проверим правильность работы построенного оракла с помошью алгоритма грубой силы
2. Запустим алгоритм Гровера.

И собственно, потестим ... 
 

Алгоритм Гровера даёт оценку требуемого количества итераций как PI/4*SQRT(2^n)
А вы точно уверены, что квантовых компов с архитектурой Неймановского типа не сделают(-ли)?
